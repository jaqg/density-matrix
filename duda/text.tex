% ------
\section{Cálculos con DALTON}
% ------
Para los cálculos en DALTON, uso el siguiente archivo \inline{.dal} para distintos
archivos \inline{H2O-$n$.mol} en los que voy cambiando la distancia \ch{H-O} 
(para ambos \ch{H} manteniendo el ángulo \ch{H-O-H})
\begin{lstlisting}[language=bash]{}
**DALTON INPUT
.RUN RESPONSE
**WAVE FUNCTIONS
.HF
.MP2
.MCSCF
.NEPOLD
*SCF INPUT
.DOUBLY OCCUPIED
3 1 1 0
*CONFIGURATION INPUT
.SYMMETRY
1
.SPIN MULTIPLLICITY
1
.INACTIVE
1 0 0 0
.CAS SPACE
4 2 2 0
.ELECTRONS
8
**END OF DALTON INPUT
\end{lstlisting}

% ------
\section{Extracción y lectura de $D^{(1)}_{ij}, D^{(2)}_{ijkl}, h_{ij}$ y $\Braket{ij | kl}$}
% ------
Las RDMs las extraigo de SIRIFC con la subrutina \inline{RD_SIRIFC}.

\subsubsection{Extracción de $\mat{D^{(1)}}$} % (fold)

Primero extraigo el array con los elementos de la triangular en \inline{AVEC}
y creo una matriz \inline{DVMAT} completa:
%-----------------------------------------------
\begin{lstlisting}[language=fortran]{}
! Initialize AVEC & DVMAT
!    AVEC: vector with upper triangular elements; AVEC(NNASHX)
!    DVMAT: complete matrix; DVMAT(NASHT, NASHT)
allocate(avec(nnashx), dvmat(nasht, nasht))
avec = 0.d0
dvmat = 0.d0

! Extract DV from SIRIFC
call RD_SIRIFC('DV', FOUND, AVEC)

! Complete the full matrix, DVMAT, from the triangular, AVEC
k = 0
do i = 1, nasht
    do j = 1, i
        k = k + 1
        dvmat(i,j) = avec(k)
        dvmat(j,i) = avec(k)  ! mirror the upper triangular
    end do
end do
\end{lstlisting}

Esta matriz se corresponde al bloque activo-activo, $\mat{D^{(1)}_{\text{a-a}}}$,
de la  1-RDM completa 
\begin{equation}
    \mat{D^{(1)}} =
    \begin{pmatrix}
        \mat{D^{(1)}_{\text{i-i}}} & \mat{D^{(1)}_{\text{i-a}}} & \mat{D^{(1)}_{\text{i-v}}} \\
        \mat{D^{(1)}_{\text{i-a}}} & \mat{D^{(1)}_{\text{a-a}}} & \mat{D^{(1)}_{\text{a-v}}} \\
        \mat{D^{(1)}_{\text{i-v}}} & \mat{D^{(1)}_{\text{a-v}}} & \mat{D^{(1)}_{\text{v-v}}} \\
    \end{pmatrix}
    .
\end{equation}

Creo la matriz completa teniendo en cuenta que el bloque inactivo-inactivo
viene dado por 
\begin{equation}
         D^{(1)}_{ij} = 2\delta_{ij},
\end{equation}
según
% ---------------------------------------------------
\begin{lstlisting}[language=fortran]{}
         ! Initialize D1MO
         allocate(d1mo(norbt, norbt))
         d1mo = 0.d0

         ! Fill the inactive orbitals
         do i = 1, nisht
            d1mo(i,i) = 2.d0
         end do

         ! Fill the active orbitals
         do i = 1, nasht
             do j = 1, nasht
                 d1mo(nisht+i, nisht+j) = dvmat(i,j)
             end do
         end do
\end{lstlisting}
Finalmente escribo \inline{d1mo} a un archivo.

\subsubsection{Extracción de $\mat{D^{(2)}}$} % (fold)
De manera análoga, extraigo el array \inline{AVEC} y primero creo la matriz
empaquetada \inline{AMAT}

\begin{lstlisting}[language=fortran]{}
         ! Initialize AVEC, AMAT & PVMAT
         !    AVEC: vector with matrix elements; AVEC(NNASHX*NNASHX)
         !    AMAT: 2D matrix from AVEC; AMAT(NNASHX,NNASHX)
         !    PVMAT: 4D AMAT unpacked matrix; PVMAT(NASHT,NASHT,NASHT,NAHST)
         allocate(avec(nnashx*nnashx), amat(nnashx,nnashx),
     &       pvmat(nasht,nasht,nasht,nasht))
         avec = 0.d0
         amat = 0.d0
         pvmat = 0.d0

         ! Call RD_SIRIFC
         call RD_SIRIFC('PV', FOUND, AVEC)

         ! Create AMAT from AVEC
         ijkl = 0
         do kl=1, nnashx
             do ij=1, nnashx
                 ijkl = ijkl + 1
                 amat(ij,kl) = avec(ijkl)
             end do
         end do
\end{lstlisting}
que desempaqueto en \inline{pvmat} según
\begin{lstlisting}[language=fortran]{}
         ! Unpack the PV matrix
         kl = 0
         do k=1, nasht
             do l=1, k
                 kl = kl + 1
                 ij = 0
                 do i=1, nasht
                     do j=1, i
                         ij = ij + 1
                         pvmat(i,j,k,l) = amat(ij,kl)
                         pvmat(j,i,k,l) = amat(ij,kl)
                         pvmat(i,j,l,k) = amat(ij,kl)
                         pvmat(j,i,l,k) = amat(ij,kl)
                     end do
                 end do
             end do
         end do
\end{lstlisting}

Construyo la matriz completa para todo el CAS y completo el bloque inactivo-inactivo
como 
\begin{equation}
    D_{ijkl}^{(2)} = 2 \delta_{ij}  \delta_{kl} - \delta_{il} \delta_{jk}
    ,
\end{equation}
\begin{lstlisting}[language=fortran]{}
         ! Initialize D2MO
         allocate(d2mo(norbt, norbt, norbt, norbt))
         d2mo = 0.d0

         ! For the inactive space
         do i=1, nisht
             do j=1, i
                ! Occupied orbitals:
                d2mo(i,i,j,j) = 2.d0   ! Case for i=j, k=l
                ! Interchange of electrons:
                ! (-1 to avoid re-countering the same pair)
               d2mo(i,j,j,i) = -1.d0  ! Case for i=l, j=k
             end do
         end do
\end{lstlisting}
y el \nota{bloque activo-activo} a partir de la matriz que había sacado anteriormete como
\begin{lstlisting}[language=fortran]{}
         ! Fill the active orbitals
         do i=1, nasht
             do j=1, i
                 do k=1, nasht
                     do l=1, k
                         kk = k + nisht
                         ll = l + nisht
                         d2mo(i,j,kk,ll) = pvmat(i,j,k,l)
                         d2mo(j,i,kk,ll) = pvmat(j,i,k,l)
                         d2mo(i,j,ll,kk) = pvmat(i,j,l,k)
                         d2mo(j,i,ll,kk) = pvmat(j,i,l,k)
                     end do
                 end do
             end do
         end do
\end{lstlisting}

Por último, los bloques cruzados inactivo-activo como se indica en el artículo
que te mandé (Maradzike, 2017) en las ecuaciones 38 y 39:
\begin{align}
    D^{(2)}_{ijtu} & = D^{(2)}_{tuij} = D^{(1)}_{tu} \delta_{ij} ,\\
    D^{(2)}_{iutj} & = D^{(2)}_{tjiu} = -\frac{1}{2} D^{(1)}_{tu} \delta_{ij} ,
\end{align}
para $i,j$ orbitales inactivos y $t,u$ activos.
Lo \nota{programo} como
\begin{lstlisting}[language=fortran]{}
         ! Fill the (inactive-active) crossed blocks
         do i=1, norbt
            do it=1, norbt
                do iu=1, norbt

c                  ! if (i,j \in inactive):
                   if ( i.le.nisht .and. j.le.nisht
c                  ! or (i,j \in virtual):
     &            .or.  i.gt.nisht+nasht .and. j.gt.nisht+nasht
c                ! and (t,u \in active), i.e. (t,u not \in inactive):
     &           .and.  it.gt.nisht .and. iu.gt.nisht
c                ! and (t,u not \in virtual):
     &           .and.  it.le.nisht+nasht .and. iu.le.nisht+nasht ) then
c
                       ! D^(2)_{ijtu} = D^(2)_{tuij} = D^(1)_{tu} d_{ij}
                       d2mo(i,i,it,iu) = dvmat(it,iu)
                       d2mo(it,iu,i,i) = dvmat(it,iu)
c
                       ! D^(2)_{iutj} = D^(2)_{tjiu} = -1/2 D^(1)_{tu} d_{ij}
                       d2mo(i,iu,it,i) = -1.d0/2.d0 * dvmat(it,iu)
                       d2mo(it,i,i,iu) = -1.d0/2.d0 * dvmat(it,iu)
c
                    end if
                end do
            end do
         end do
\end{lstlisting}
Escribo la matriz completa a un archivo como
\begin{lstlisting}[language=fortran]{}
write(...) k, l, i, j, d2mo(k,l,i,j)
\end{lstlisting}

\subsubsection{Extracción de $\mat{h}$ y $ \Braket{ij | kl}$} % (fold)
Básicamente, uso las rutinas que me proporcionaste de Neptunus con alguna
modificación.
En estos días de desquicio he estado probando todo lo que se me ha ocurrido.
Entre otras, he sacado el archivo \inline{molecule.fmt}, del que leo las
matrices.
Obtengo los mismos resultados con \textit{mis matrices} que con éstas últimas,
así que entiendo que aquí no hay error.

\subsubsection{Lectura de $\mat{h}$ y $\mat{D^{(1)}}$} % (fold)
Como las escribo por índices, leo los índices y su elemento.
Además son simétricas así que no puede haber fallo en liarme con intercambiar
los índices de la escritura a la lectura.

\subsubsection{Extracción de $\mat{D^{(2)}}$ y $\Braket{ij | kl}$} % (fold)
Leo la $\mat{D^{(2)}}$, siguiendo como está escrita, según
\begin{lstlisting}[language=fortran]{}
        ! Read the triangular part of Amat
        iind = -1
        jind = -1
        kind = -1
        lind = -1
        do
            read(nlu,*,iostat=ios) kind, lind, iind, jind, xint
            if (ios /= 0) stop
            if (kind.eq.0 .or. lind.eq.0 .or. iind.eq.0 .or. jind.eq.0) exit

            Amat(kind,lind,iind,jind) = xint
        end do

        ! Simetrize the 4D tensor
        if (is_triangular .eqv. .true.) then
            do k=1, n
                do l=k, n
                    do i=1, n
                        do j=i, n
                            Amat(j,i,l,k) = Amat(i,j,k,l)
                            Amat(i,j,l,k) = Amat(i,j,k,l)
                            Amat(j,i,k,l) = Amat(i,j,k,l)
                        end do
                    end do
                end do
            end do
        end if
\end{lstlisting}
Creo que aquí no hay fallo aunque, un punto importante, es que \nota{no cumple
la condición de normalización} 
\begin{equation}
    \trace \left[ \mat{D^{(2)}} \right] =
    \sum_{ik}  D^{(2)}_{iikk} =
    \frac{N\left( N-1 \right)}{2} =
    \binom{N}{2}
    .
\end{equation}

La $\mat{D^{(1)}}$ \textbf{sí} que cumple la condición de normalización
$\trace \left[ \mat{D^{(1)}} \right] = N$.

Como te comenté por correo, las integrales bielectrónicas las escribo como
\begin{lstlisting}[language=fortran]{}
write(...) k, l, i, j, h2mo(k,l,i,j)
\end{lstlisting}
Me comentaste que están en notación química, es decir, $\pbraket{kl | ij}$.
Como en el documento uso notación Dirac porque es la que usan los autores
de los artículos/libros que he estado siguiendo, \nota{la leo teniendo en cuenta que
$ \pbraket{kl | ij} = \Braket{ki | lj}$}, en una rutina exactamente igual a la
de $\mat{D^{(2)}}$, pero con la siguiente modificación
\begin{lstlisting}[language=fortran]{}
            ! xint = (kl|ij) -> <ki|lj>
            Amat(kind,iind,lind,jind) = xint
\end{lstlisting}

% ------
\section{Extracción de los números de ocupación $\left\{ n_p \right\}$, \inline{ON(:)}}
% ------
Primero checkeo si $\mat{D^{(1)}}$ ya es diagonal y, en caso contrario,
la diagonalizo con una subrutina que tengo escrita de Jacobi, y haría una
transformación unitaria de las matrices de integrales con los vectores propios.
Como la matriz que sale de Dalton ya es diagonal, no desarrollo más esa condición.

Esto me lleva a una duda, \nota{como las RDMs extraídas de Dalton ya son diagonales,
¿entonces las matrices de las integrales, $h_{ij}, \Braket{ij | kl}$ están ya
en la base de orbitales (moleculares) naturales? ¿Básicamente, las matrices de integrales
ya están en base de los vectores propios de $\mat{D^{(1)}}$?}

Entiendo que esto es importante ya que, al fin y al cabo, todas las aproximaciones
a $\mat{D^{(2)}}$ son en función a los números de ocupación naturales (valores propios
de $\mat{D^{(1)}}$), de manera que al calcular $E_{\text{ee}}$ como sumas del estilo
$D^{(2)}_{pqrs} \Braket{pq | rs}$, la integral bielectrónica está expresada
en base de orbitales naturales (vectores propios de $\mat{D^{(1)}}$).

Por tanto, tal cual tengo $\mat{D^{(1)}}$ de Dalton que ya es diagonal,
¿$n_1 = D^{(1)}_{11}$ se corresponde a la ocupación del orbital cuya integral
sobre $\hat{h}$ es $h_{11}$?
O dicho de otra manera, \nota{¿la indexación se corresponde entre todas las
matrices?}

% ------
\section{Cálculo de la energía}
% ------
Para no extender más el documento, no entro en las distintas aproximaciones,
ya que vale (al menos en un principio) con comprobar que la energía a partir
de $\mat{D^{(1)}}$ y $\mat{D^{(2)}}$ es equivalente a la que pueda obtener con
Dalton o Gaussian.

La energía la calculo como 
\begin{equation}
    E = E_{\text{oe}} + E_{\text{ee}}
    ,
\end{equation}
donde 
\begin{equation}
    E_{\text{oe}} = 
    \trace \left[ \mat{h} \mat{D^{(1)}} \right] =
    \sum_{pq} h_{pq} D^{(1)}_{pq}
    ,
\end{equation}
y 
\begin{equation}
    E_{\text{ee}} =
    \frac{1}{2} \sum_{pqrs} D^{(2)}_{pqrs} \Braket{rs | pq} 
    .
\end{equation}

Para no entrar tampoco en la conversión de MOs a spin-orbitales, hago el cálculo
con los valores que tengo directamente de Dalton, es decir
\begin{itemize}
    \item $\mat{D^{(1)}}$ en base MO con $0 \le D^{(1)}_{ii} \le 2$
    \item $\mat{D^{(2)}}$ en base MO
    \item $h_{pq}$ en base MO
    \item $\Braket{rs | pq}$ (aunque escrito en notación Dirac) en base MO
\end{itemize}

% ---------
\subsection{Ejemplo para \inline{H2O-0.mol}}
% ---------
Sea el archivo \inline{H2O-0.mol}
\begin{lstlisting}[language=bash]{}
BASIS
6-31G**
 Water using the 6-31G** basis
 Using automatic symmetry detection.
Atomtypes=2
Charge=8.0 Atoms=1
O 0.00000000    0.37558843   -0.14534628
Charge=1.0 Atoms=2
H_a 0.00000000    0.78383672   -0.43402142
H_b 0.00000000   -0.03265986   -0.43402142
\end{lstlisting}
correspondiente a una distancia \ch{H-O} de $d = 0.5\  \text{\AA}$, obtengo
\begin{itemize}
    \item $E_{\text{oe}} = -124.3105$ Hartrees
    \item $E_{\text{ee}} = 0.4417$ Hartrees
    \item $E = E_{\text{oe}} + E_{\text{ee}} = -123.8688$ Hartrees
\end{itemize}
lo cual no tiene ni medio sentido teniendo en cuenta las energías que obtengo
del cálculo en Dalton
\begin{itemize}
    \item $E_{\text{Dalton}} = -66.16992$ Hartrees
\end{itemize}
que obtengo de la última línea que encuentra con \inline{MCSCF energy}.

% ---------
\subsection{Scan para el \ch{H2O}}
% ---------
En la siguiente tabla incluyo las energías que obtengo para todas las estructuras
que, en un principio, tenía creadas con un incremento de $\Delta d = 0.5\ \text{\AA}$
\begin{table}[b]
    \ra{1.2} % Spacing between lines of table
    \caption{}
    \centering
    \begin{tabular}{@{}c c c@{}}
        \toprule
        $d\ \left( \text{\AA} \right)$ & $E$ (Hartree) & $E_{\text{Dalton}}$ (Hartree)\\
        \midrule
        0.5 &  -123.8688 &  -66.1699 \\
        1.0 &  -115.7894 &  -74.8826 \\
        1.5 &  -111.1165 &  -76.0579 \\
        2.0 &  -107.7657 &  -76.1280 \\
        2.5 &  -105.0204 &  -76.0252 \\
        3.0 &  -102.7526 &  -75.9260 \\
        3.5 &  -101.2976 &  -75.8616 \\
        4.0 &  -100.7092 &  -75.8282 \\
        \bottomrule
    \end{tabular}
\end{table}

La cosa es que, no sólo salen energías absurdas, como que la menor energía sea
para el caso en el que los átomos están más próximos, si no que tampoco siguen la
\textit{tendencia} de las energías obtenidas con Dalton (la forma de la curva),
ni hay un mínimo.
